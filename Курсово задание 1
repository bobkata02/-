# Югозападен университет "Неофит Рилски"
# Курсово задание
# Конзолни команди
### Факултетен номер - 21251421036, ИСТ3
### Изготвил - Боян Лазаров

Конзолните програми и команди са сред основните инструменти в операционните системи, които ни позволяват да взаимодействаме с компютърната среда посредством текстов интерфейс.
Три от най-популярните конзолни програми са PowerShell, CMD и Bash.

## PowerShell
PowerShell е разработен от Microsoft и е мощен конзолен скриптов език и команден интерпретатор. Той предлага разширени възможности за автоматизация и управление на Windows операционната система. PowerShell използва обекти и команди, наречени "cmdlets", които се използват за извършване на различни задачи. В PowerShell можем да изпълняваме команди за управление на файловата система, мрежовите настройки, регистъра и много други.

Някои от най-често използваните команди в PowerShell са:
- Get-ChildItem – извежда списък с файловете и директориите в текущата директория;
- Set-Location – променя текущата директория;
- New-Item – създава нов файл или директория;
- Remove-Item – изтрива файл или директория;
- Copy-Item – копира файл или директория от едно място на друго;
- Move-Item – премества файл или директория от едно място на друго;
- Get-Process – извежда информация за текущите процеси;
- Stop-Process – спира определен процес;
- Get-Service – извежда информация за системните услуги;
- Restart-Service – рестартира определен системен сервиз.

## 1.Get-ChildItem
Кратката Get-ChildItem команда получава елементите в едно или повече определени местоположения. Ако елементът е контейнер, той получава елементите вътре в контейнера, известни като дъщерни елементи. Можете да използвате параметъра Recurse , за да получите елементи във всички дъщерни контейнери и да използвате параметъра Depth , за да ограничите броя на нивата за рекурсия.

Get-ChildItemне показва празни директории. Когато дадена Get-ChildItemкоманда включва параметрите Depth или Recurse , празните директории не се включват в изхода.

Местоположенията са изложени на достъп Get-ChildItemот доставчиците на PowerShell. Местоположението може да бъде директория на файловата система, кошер на системния регистър или хранилище на сертификати. Някои параметри са достъпни само за определен доставчик.

Този пример получава дъщерните елементи от директория на файловата система. Показват се имената на файловете и поддиректориите. За празни местоположения командата не връща никакви резултати и се връща към подканата на PowerShell.

Командлетът Get-ChildItemизползва параметъра Path , за да посочи директорията C:\Test. Get-ChildItemпоказва файловете и директориите в конзолата на PowerShell.
```cpp
Get-ChildItem -Path C:\Test

Directory: C:\Test

Mode                LastWriteTime         Length Name
----                -------------         ------ ----
d-----        2/15/2019     08:29                Logs
-a----        2/13/2019     08:55             26 anotherfile.txt
-a----        2/12/2019     15:40         118014 Command.txt
-a----         2/1/2019     08:43            183 CreateTestFile.ps1
-ar---        2/12/2019     14:31             27 ReadOnlyFile.txt
```
По подразбиране Get-ChildItemизброява режима ( Атрибути ), LastWriteTime , размера на файла ( Дължина ) и Името на елемента. Буквите в свойството Mode могат да се интерпретират по следния начин:

- l(връзка)
- d(указател)
- a(архив)
- r(Само за четене)
- h(скрит)
- s(система)

## 2.Set-Location
Командaтa Set-Location задава работното местоположение на определено място. Това местоположение може да бъде директория, поддиректория, местоположение в регистъра или всеки път на доставчик.

PowerShell 6.2 добави поддръжка за -и +като стойности за параметъра Path . PowerShell поддържа история на последните 20 местоположения, които могат да бъдат достъпни с -и +. Този списък е независим от стека за местоположение, достъпен чрез параметъра StackName .

Пример: Задаване на текущото местоположение и показване на това местоположение
```cpp
PS C:\> Set-Location -Path "Env:\" -PassThru

Path
----
Env:\

PS Env:\>
```
Тази команда задава текущото местоположение в основата на Env:устройството. Той използва параметъра PassThru , за да насочи PowerShell да върне обект PathInfo , който представлява Env:\местоположението.

## 3.New-Item
Командaта New-Item създава нов елемент и задава неговата стойност. Типовете елементи, които могат да бъдат създадени, зависят от местоположението на елемента. Например във файловата система New-Item създава файлове и папки. В регистъра New-Item създава ключове и записи в регистъра.

New-Item може също да задава стойността на елементите, които създава. Например, когато създава нов файл, New-Item може да добави първоначално съдържание към файла.

Пример: Използвайте заместващи знаци за създаване на файлове в множество директории
Командлетът New-Item поддържа заместващи знаци в параметъра Path . Следната команда създава temp.txt файл във всички директории, посочени от заместващите символи в параметъра Path .
```cpp
Get-ChildItem -Path C:\Temp\

Directory:  C:\Temp

Mode                LastWriteTime     Length Name
----                -------------     ------ ----
d-----        5/15/2019   6:45 AM        1   One
d-----        5/15/2019   6:45 AM        1   Two
d-----        5/15/2019   6:45 AM        1   Three

New-Item -Path C:\Temp\* -Name temp.txt -ItemType File | Select-Object FullName

FullName
--------
C:\Temp\One\temp.txt
C:\Temp\Three\temp.txt
C:\Temp\Two\temp.txt
```
Командaта Get-ChildItem показва три директории под C:\Tempдиректорията. С помощта на заместващи символи кратката New-Item команда създава temp.txt файл във всички директории в текущата директория. Командлетът New-Item извежда елементите, които сте създали, към които се предава, Select-Object за да провери пътищата на новосъздадените файлове.

## 4.Remove-Item
Командата Remove-Item изтрива един или повече елементи. Тъй като се поддържа от много доставчици, той може да изтрива много различни типове елементи, включително файлове, папки, ключове в регистъра, променливи, псевдоними и функции.

Пример: Изтриване на файлове със специални знаци
Следващият пример показва как да изтриете файлове, които съдържат специални знаци като скоби или кръгли скоби.
```cpp
Get-ChildItem

Directory: C:\temp\Downloads

Mode                LastWriteTime         Length Name
----                -------------         ------ ----
-a---          6/1/2018  12:19 PM           1362 myFile.txt
-a---          6/1/2018  12:30 PM           1132 myFile[1].txt
-a---          6/1/2018  12:19 PM           1283 myFile[2].txt
-a---          6/1/2018  12:19 PM           1432 myFile[3].txt

Get-ChildItem | Where-Object Name -Like '*`[*'

Directory: C:\temp\Downloads

Mode                LastWriteTime         Length Name
----                -------------         ------ ----
-a---          6/1/2018  12:30 PM           1132 myFile[1].txt
-a---          6/1/2018  12:19 PM           1283 myFile[2].txt
-a---          6/1/2018  12:19 PM           1432 myFile[3].txt

Get-ChildItem | Where-Object Name -Like '*`[*' | ForEach-Object { Remove-Item -LiteralPath $_.Name }
Get-ChildItem

Directory: C:\temp\Downloads

Mode                LastWriteTime         Length Name
----                -------------         ------ ----
-a---          6/1/2018  12:19 PM           1362 myFile.txt
```

## 5.Copy-Item
Командата Copy-Item копира елемент от едно местоположение на друго място в същото пространство от имена. Например, може да копира файл в папка, но не може да копира файл в устройство със сертификат.

Тази кратка команда не изрязва или изтрива елементите, които се копират. Конкретните елементи, които кратката команда може да копира, зависят от доставчика на PowerShell, който излага елемента. Например, той може да копира файлове и директории в устройство с файлова система и ключове и записи в регистъра.

Тази кратка команда може да копира и преименува елементи в една и съща команда. За да преименувате елемент, въведете новото име в стойността на параметъра Дестинация . За да преименувате елемент, а не да го копирате, използвайте Rename-Item cmdlet.

Пример: Копиране на файл на отдалечен компютър
Създава се сесия към отдалечения компютър с име Server01 с идентификационните данни на Contoso\User01и съхранява резултатите в променливата с име $Session.

Кратката Copy-Itemкоманда копира test.logот D:\Folder001папката в C:\Folder001_Copy папката на отдалечения компютър, като използва информацията за сесията, съхранена в променливата $Session. Оригиналният файл не е изтрит.
```cpp
$Session = New-PSSession -ComputerName "Server01" -Credential "Contoso\User01"
Copy-Item "D:\Folder001\test.log" -Destination "C:\Folder001_Copy\" -ToSession $Session
```

## 6.Move-Item
Кратката Move-Item команда премества елемент, включително неговите свойства, съдържание и дъщерни елементи, от едно местоположение на друго място. Локациите трябва да се поддържат от един и същ доставчик.

Например, може да премести файл или поддиректория от една директория в друга или да премести подключ на системния регистър от един ключ в друг. Когато преместите елемент, той се добавя към новото местоположение и се изтрива от първоначалното си местоположение.

Пример: Преместете файл в друга директория и го преименувайте
Тази команда премества Test.txt файла от C:устройството в директорията E:\Tempи го преименува от test.txt на tst.txt.
```cpp
Move-Item -Path C:\test.txt -Destination E:\Temp\tst.txt
```

## 7.Get-Process
Командата Get-Process получава процесите на локален компютър.

Без параметри тази кратка команда получава всички процеси на локалния компютър. Можете също така да посочите конкретен процес чрез име на процес или идентификатор на процес (PID) или да прехвърлите обект на процес през тръбопровода към тази кратка команда.

По подразбиране тази кратка команда връща процесен обект, който има подробна информация за процеса и поддържа методи, които ви позволяват да стартирате и спирате процеса. Можете също да използвате параметрите на Get-Processcmdlet, за да получите информация за версията на файла за програмата, която се изпълнява в процеса, и да получите модулите, които процесът е заредил.

Пример: Вземете всички налични данни за един или повече процеси
```cpp
Get-Process winword, explorer | Format-List *
```
Тази команда получава всички налични данни за процесите Winword и Explorer на компютъра. Той използва параметъра Name , за да посочи процесите, но пропуска незадължителното име на параметъра. Операторът на тръбопровода ( |) предава данните на Format-Listкратката команда, която показва всички налични свойства ( *) на обектите на процеса Winword и Explorer.

## 8.Stop-Process
Командата Stop-Process спира един или повече работещи процеси. Можете да посочите процес чрез име на процес или идентификатор на процес (PID) или да предадете обект на процес към Stop-Process. Stop-Processработи само върху процеси, изпълнявани на локалния компютър.

В Windows Vista и по-нови версии на операционната система Windows, за да спрете процес, който не е собственост на текущия потребител, трябва да стартирате PowerShell, като използвате опцията Изпълни като администратор. Освен това няма да бъдете подканени за потвърждение, освен ако не посочите параметъра Confirm . 

Пример: Спрете процес и установете, че е спрял
```cpp
calc
$p = Get-Process -Name "calc"
Stop-Process -InputObject $p
Get-Process | Where-Object {$_.HasExited}
```
Тази поредица от команди стартира и спира Calcпроцеса и след това открива процеси, които са спрели.
Първата команда стартира екземпляр на калкулатора.
Втората команда използва Get-Processgets обект, който представлява Calc процеса, и след това го съхранява в променливата.
Третата команда спира Calcпроцеса. Той използва параметъра InputObject , за да предаде обекта на Stop-Process.
Последната команда получава всички процеси на компютъра, които са били изпълнявани, но сега са спрени. Използва се Get-Processза получаване на всички процеси на компютъра. Операторът на тръбопровода ( |) предава резултатите на Where-Objectcmdlet, който избира онези, при които стойността на свойството HasExited е $True. HasExited е само едно свойство на процесните обекти. За да намерите всички свойства, въведете Get-Process | Get-Member.

## 9.Get-Service
Кратката Get-Service команда получава обекти, които представляват услугите на компютър, включително работещи и спрени услуги. По подразбиране, когато Get-Serviceсе изпълнява без параметри, се връщат всички услуги на локалния компютър.
Можете да насочите тази кратка команда да получава само определени услуги, като посочите името на услугата или показваното име на услугите, или можете да насочите сервизни обекти към тази кратка команда.
Пример: Избройте услугите на компютъра, които имат зависими услуги
Този пример получава услуги, които имат зависими услуги.
```cpp
Get-Service |
  Where-Object {$_.DependentServices} |
    Format-List -Property Name, DependentServices, @{
      Label="NoOfDependentServices"; Expression={$_.dependentservices.count}
    }

Name                  : AudioEndpointBuilder
DependentServices     : {AudioSrv}
NoOfDependentServices : 1

Name                  : Dhcp
DependentServices     : {WinHttpAutoProxySvc}
NoOfDependentServices : 1
---
```
Командлетът Get-Service получава всички услуги на компютъра и изпраща обектите по тръбопровода. Кратката Where-Object команда избира услугите, чието свойство DependentServices не е null.

Резултатите се изпращат по тръбопровода към Format-Listcmdlet. Параметърът Property показва името на услугата, името на зависимите услуги и изчислено свойство, което показва броя на зависимите услуги за всяка услуга.

## 10.Restart-Service
Кратката Restart-Service команда изпраща съобщение за спиране и след това съобщение за стартиране към Windows Service Controller за определена услуга. Ако дадена услуга вече е била спряна, тя се стартира без да ви уведомява за грешка. Можете да посочите услугите чрез техните имена на услуги или показвани имена, или можете да използвате параметъра InputObject, за да подадете обект, който представлява всяка услуга, която искате да рестартирате.

Пример: Рестартирайте услуга на локалния компютър
```
PS C:\> Restart-Service -Name winmgmt
```
Тази команда рестартира услугата Windows Management Instrumentation (WinMgmt) на локалния компютър.
## CMD (Command Prompt)
CMD (Command Prompt) е стандартният конзолен интерфейс на Windows. Въпреки че CMD не предлага толкова широк набор от функции като PowerShell, той все пак е полезен за изпълнение на базови операции и команди в операционната система. С CMD можем да стартираме програми, да управляваме файловата система, да конфигурираме мрежови настройки и други подобни дейности. CMD използва команди и синтаксис, които са по-подобни на тези в старите MS-DOS системи.

## Bash
Bash е стандартният команден интерпретатор и скриптов език за Unix и Linux базирани операционни системи. Той предлага мощни инструменти за автоматизация и управление на системата. Bash командите могат да бъдат използвани за навигация във файловата система, манипулиране на файлове и директории, управление на процесите и конфигуриране на системните настройки.

Някои от най-често използваните команди в Bash са:

- ls – извежда списък с файловете и директориите в текущата директория
- cd – променя текущата директория
- mkdir – създава нова директория
- rm – изтрива файл или директория
- cp – копира файл или директория от едно място на друго
- mv – премества файл или директория от едно място на друго
- ps – извежда списък с текущите процеси
- kill – спира определен процес
- grep – търси за даден израз във файл или изход от команда
- ssh – се свързва към друго устройство чрез SSH (Secure Shell) протокол.

Това са само някои от многото команди, които можете да използвате в PowerShell, CMD и Bash. Всяка от тези конзолни програми предлага богато разнообразие от команди и възможности, които могат да бъдат използвани за изпълнение на различни задачи и автоматизация на операциите във вашия компютър.

Благодарение на гъвкавостта си, Bash се използва широко в Linux системите и се счита за едно от най-мощните средства за автоматизация на задачи в командния ред.

## Приложения, използващи Command Line Interface
Съществуват компютърни приложения, които също използват Command Line Interface.

Компютърните приложения може да не поддържат, да поддържат някои или да поддържат и трите главни механизма на взаимодействие чрез команди:

1.Параметри: Повечето операционни системи поддържат начин за подаване на допълнителни параметри към програма, когато тя бъде стартирана. Когато дадена програма бъде стартирана от командния интерпретатор на операционната система, допълнителен текст заедно с името на програмата биват подавани към стартираната програма.
2.Интерактивни сесии: След стартирането си дадена програма може да създаде оператор с независими ресурси, за да въвежда команди под формата на текст.
3.Вътрешно-системно взаимодействие: Повечето операционни системи поддържат начини за вътрешно-системни взаимодействия. Командите от потребителски процеси могат да бъдат пренасочени към командния интерфейс, чрез един от тези методи.

## CLI програми
Някои приложения поддържат само този тип интерфейс, като на потребителя се предоставя възможност за подаване на команди и поведението на програмата се определя от тях. Примери за такива програми са:

- DEBUG
- Diskpart
- Ed
- Edlin
- Fdisk
- Ping

## Хибридни програми
Някои компютърни програми поддържат както интерфейс с въвеждане на команди (CLI), така и графичен интерфейс (GUI). В някои случаи програмата с графичен интерфейс е просто „обвивка“ около отделен изпълним файл на програма с въвеждане на команди. В други случаи някои програми предлагат алтернатива с въвеждане на команди, на програмата с графичен интерфейс. Не винаги обаче двата варианта предлагат сходна функционалност. Например MATLAB, компютърна програма за числени анализи, не предлага графична среда за някои изчисления, но интерфейсът с въвеждане на команди може да се справи с всяко изчисление, което MATLAB поддържа.

Ранните игри на компанията Sierra, като първите 3 версии на играта King’s Quest (1984 – 1986), използват команди от вграден в играта конзолен прозорец, чрез които героят се движи.
## Използване
Интерфейсът с въвеждане на команди се използва, когато широк набор от команди или заявки и голям брой настройки към тях могат да бъдат въведени по-бързо като текстови команди, отколкото чрез система с потребителски интерфейс. Типичен пример за това са командните прозорци на операционните системи. Този тип въвеждане на данни се използва и при системи, които нямат достатъчно ресурс за ползване на графичен интерфейс.

Интерфейсът с въвеждане на команди най-вече се използва от програмисти или системни администратори, в научни среди или от по-технически напреднали потребители. Той също е разпространен сред потребители с проблеми в зрението, понеже командите и отговорите към тях, могат да бъдат възпроизвеждани чрез т.нар. Брайлови терминали.

## Структура на командния интерпретатор
```sh
prompt command param1 param2 param3 ... paramN
```
- Prompt – генерира се от програмата и извиква съдържание за потребителя.
- Command (команда) – извиква се от потребителя. Командите са обикновено една от трите вида:
- Вътрешна – разпозната и обработвана от самия интерпретатор на командния ред и независеща от никакъв външен изпълняващ файл (.exe).
- Добавена – отделен изпълняващ файл, основно считан за част от операционната среда и винаги добавен вътре заедно с ОС.
- Външна – външни изпълними файлове, които не са част от основната ОС, но са добавени от други източници за специфични цели и приложения.
- param1 ...paramN – Допълнителни параметри добавени от потребителя. Формата и значението на параметрите зависят от извиканата команда. В случай на добавена или външна команда, стойностите на параметрите се предават от процеса (определен от командата), когато процесът е стартиран от ОС. Параметрите могат да бъдат аргументи или опции.
В този пример сепараторите между елементите на командния интерфейс са празни полета (whitespace characters), а в края на реда сепаратора е нов ред. Това е широко употребявана (но не универсална) практика за командните интерфейси.

Интерефейс с команден ред се състои основно от синтаксис и семантика. Синтаксисът е „букварът“ или още граматиката, която всички команди трябва да следват. В случаите с операционната система MS-DOS или Unix всяка от тях дефинира техен собствен списък от правила, които всички команди следват. Когато има вградена системи (embedded systems), всяка компания продавач като Nortel, Juniper Networks или Cisco Systems, дефинира свой собствен списък с правила, към които командите вътре в командния интерпретатор се приспособяват. Тези правила също определят как потребителят ще навигира през системата от команди. Семантиката определя какъв вид операции са възможни, на какъв вид данни тези операции могат да бъдат изпълнени и как граматиката представя тези данни и операции – символичното значение в синтаксиса.

Два различни командни интерфейса могат да съответстват по синтаксис или по семантика, но само когато те съответстват и по двете те могат да бъдат считани за достатъчно близки, за да позволят на потребителя да използва и двата командни интерпретатора без да е необходимо самообучение, както и възможността за преупотреба на кода.

Един обикновен команден интерпретатор ще изпише „prompt“, ще приеме „команден ред“ въведен от потребителя и подаден за изпълнение с клавиша „Enter“, ще изпълни указаната команда и ще осигури текстова визуализация на резултати или съобщения за грешки. Един по-съвременен команден интерфейс би валидирал (оценка на данните), интерпретирал и разширил параметрите на командния интерфейс преди да изпълни подадената команда, и допълнително би могъл да прихване или пренасочи своя изход (резултат от изчисления).

За разлика от бутон или прозорец за меню в GUI (графичен потребителски интерфейс), командният интерпретатор е самодокументиращ се, показващ само това, което потребителят иска да бъде направено. В допълнение командният интерпретатор включва стандартни настройки, които могат да бъдат достъпени за промяна на резултатите. В случай че настройките са от помощ при компилирането на кода, така промененият команден интерпретатор може да бъде запазен чрез низ от символи (character string) или псевдоним, който представя цялата команда, или няколко команди могат да бъдат групирани, за да изпълняват по-сложна последователност – например компилиране на програмата, нейното инсталиране и пускане – създавайки единична цялост, наречена командна процедура или код, който сам по себе си може да бъде третиран като команда. Тези предимства означават, че потребителят трябва да изчисли комплексна команда или серии такива само веднъж, защото те могат да бъдат запазени, за да бъдат използвани отново.

Командите задавани на командния интерпретатор са често в една от следните форми:
>правиНещо как къмФайл(ове)
>правиНещо как файлИзточник целевиФайл
>правиНещо как <входенФайл> изходенФайл
>правиНещо как | правиНещо как | правиНещо как > изходенФайл

където „правиНещо“ като резултат е команда, а “как“ е обстоятелство (например как да бъде изпълнена командата) и „къмФайл“ е обект или обекти (обикновено един или повече файла), където командата трябва да действа (оперира). Символът ‘>’ в третия пример е оператор за пренасочване, който указва на командния интерпретатор да изпрати резултата от действията не към екрана, а към файла написан от дясно след ‘>’. Това действие ще презапише съдържанието на файла. Използвайки „>>“ ще пренасочи изхода по същия начин, ще го продължи файла без да изтрива текущото му състояние. Друг пренасочващ оператор е вертикалната черта ‘ | ’, който създава канал за обработка на процеса, където изходът на една команда става вход на следващата команда.

## Изполвани източници:
1.https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.management/restart-service?view=powershell-7.4
2.https://urocibg.eu/%D0%B2%D1%81%D0%B8%D1%87%D0%BA%D0%BE-%D0%B7%D0%B0-%D0%BA%D0%BE%D0%BD%D0%B7%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%B8-%D0%B8-%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD/





